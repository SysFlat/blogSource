---
title: 指针相关
date: 2017-04-07 15:29:52
categories: C/C++
tags: 指针 , C
---

有时候觉得自己什么学了很久的C了，什么都懂。真正碰到一个大家都说了几千遍的问题，你却还有点懵逼的时候，才觉得自己是个大傻叉。人傻就要多读书啊！!！
# 指针简介
指针的3三个重要的概念：
**指针的地址**
**指针保存的地址**
**指针保存的地址所对应的值**
所谓大道至简，在复杂的东西也逃不过类比，指针也是如此。
{% note primary %}
下面有三个定理：
**1.我们把每一个存储空间看成是一个盒子，每个盒子都有自己的序列号**
**2.每个盒子里面可以存放一个数。当这个数是另外一个盒子的序列号的时候，可以通过这个序列号可以找到另外一个盒子。**
**3.每一个程序中定义的变量都有自己专属的盒子。**{% endnote %}
<!-- more -->OK，在这些定理的约束下我们再来进行讨论。我们经常称`int *p`是一个指针变量，既然是变量也有自己的盒子了。那么我们的指针变量的地址就是盒子上的地址。当盒子里存放了序列号（地址）的时候，我们就可以根据这个序列号去找另外一个盒子，进而查看另外一个盒子里面的东西。
道理就是这么简单啦~当然可以在来个图了：
![指针](/img/pointer.png)

# 所谓指针传递,值传递
这些传递方式主要是针对于函数形参和实参的传递来说的。
{% note primary %} 对于所谓指针传递，值传递，事实上我个人以为本质上完全都可以归为值传递这一类别。 {% endnote %}
为什么这么说呢，对于这样的两个函数来说
```C++
void fun(int a)
{
}
void fun2(int *a)
{
}
```
事实上`int a`,`int *a`作为形参是拥有自己的盒子的，也就是拥有自己的独立空间。这个时候数据的相互交流实际上是限于实参变量把自己盒子的数据（盒子里面存放的东西或者是盒子的标号）放到了形参变量的盒子里，并不存在说把整个盒子直接传递到函数内部的情况。
因此对于通过传递指针来改变一个数的值情况来说，本质上都是通过获取到某个盒子的标号来改变盒子里的内容来实现的。
那么对于下面的程序会出现错误结果的原因，我们也能用我们的"火眼金睛"来看穿它的本质了。
```C++
void fun1(int *m)
{
	cout<<"fun1----"<<m<<"----"<<&m<<endl;
	m = (int *)malloc(sizeof(int));
	cout<<"fun1----"<<m<<"----"<<&m<<endl;
	*m = 15;
}
int main(void)
{
	int *p = NULL;
	cout<<p<<"----"<<&p<<endl;
	fun1(p);
	cout<<p<<"----"<<&p<<endl;
	return 0;
}
/*********************************************/
运行结果:

0----0x22feac
fun1----0----0x22fe90
fun1----0x6562f0----0x22fe90
0----0x22feac
```
可以看出形参是有自己专属的盒子（独立的内存空间）。在实参p向形参传递数据的时候，将自己盒子里面的内容复制了一份传给了形参。之后形参就对着自己盒子里面的东西一顿摆弄，然而实参盒子里面的东西变化了么？自然是没有变化的。所以p依然是一个空的指针，如果你去访问p存放的指针对应的值，就会崩~~~炸了（程序崩溃）。

那么我们如何改变P的值呢？最最关键的是改变P的盒子里面装的内容！
你可以这样：
```C++
int *fun2(int *m)
{
	cout<<"fun1----"<<m<<"----"<<&m<<endl;
	m = (int *)malloc(sizeof(int));
	cout<<"fun1----"<<m<<"----"<<&m<<endl;
	*m = 15;
	return m;	
}
int main(void)
{
	int *p = NULL;
	cout<<p<<"----"<<&p<<endl;
	p=fun2(p);
	cout<<p<<"----"<<&p<<"----"<<*p<<endl;
	return 0;
}
/*********************************************/
运行结果：
0----0x22feac
fun1----0----0x22fe90
fun1----0x5f62f0----0x22fe90
0x5f62f0----0x22feac----15
```
当然也可以这样：
```C++
void fun3(int **m)
{
	*m = (int *)malloc(sizeof(int));
	**m = 23;
}
int main(void)
{
	int *p = NULL;
	cout<<p<<"----"<<&p<<endl;
	fun3((int **)&p);
	cout<<p<<"----"<<&p<<"----"<<*p<<endl;
	return 0;
}
/*********************************************/
运行结果：
0----0x22feac
0x6462f0----0x22feac----23
```
# 引用传递
引用传递是一种完全的传递，是一个完整个体的传递，它传递的东西包括盒子的标号和盒子里面的内容。
## 对于变量引用来说
```C++
int main()
{
	int i = 10;
	int &j = i;
	cout<<&i<<endl<<&j<<endl;
	return 0;
 } 	
/*********************************************/
运行结果：

0x22fea8
0x22fea8
```
## 对于函数形参引用传递-fun(int &i)类型
```C++
void fun4(int &i)
{
	cout<<"in fun4---";
	cout<<i<<"----"<<&i<<endl;
}
int main()
{
	int i = 10;
	int &j = i;
	cout<<"Before---"<<&i<<"----"<<&j<<endl;
	fun4(i);
	fun4(j);
	return 0;
 } 	
/*********************************************/
运行结果：

Before---0x22fea8----0x22fea8
in fun4---10----0x22fea8
in fun4---10----0x22fea8
```
## 对于函数形参引用传递-fun(int *&i)
```C++
void fun3(int *&i)
{
	cout<<"In fun3----";
	cout<<i<<"----"<<&i<<endl;
}
int main()
{
	int i = 10;
	int &j = i;
	int *p = &i;
	cout<<"Before---"<<&i<<"----"<<&j<<endl;
	cout<<"P------"<<p<<"------"<<&p<<endl;
	fun3(p);//这里不能传递&i的值
	return 0;
 } 	
/*********************************************/
运行结果：

Before---0x22fea8----0x22fea8
P------0x22fea8------0x22fea4
In fun3----0x22fea8----0x22fea4
```
引用传递是完全的传递在这里更能明显的表示出来。在fun3函数中我们可以看出传递进来的是p对应的变量盒子的整体，包括盒子的标号（p的地址）和盒子的内容（指针变量保存的地址），两者缺一不可，同时这也是传递`&i`会报错的原因（它只是传递了盒子的标号---变量的地址，这和形参的类型是不同的）。
# 总结
<p id="div-border-top-red">1.本质上值传递和指针传递是一种类型，它们传递的过程中只传输一个变量的一种属性（地址或者是改地址存放的值）。但是引用传递会传输一个完整的变量，包括地址和地址存放的内容。
2.对于值传递和指针传递来说，函数形参的来说都会单独分配一个独立的内存空间，但是引用传递不会，传递过来的是实参的实体。</p>

一些非常好的参考文章：
1.[http://www.cnblogs.com/uniqueliu/archive/2011/07/14/2106681.html]
2.[http://blog.csdn.net/huqinwei987/article/details/50769096]
<blockquote class="blockquote-center">完</blockquote>